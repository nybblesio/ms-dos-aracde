;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ one-on-one                                        ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³ copyright (C) 2017 jeff panici                    ³
;³ https://nybbles.io                                ³
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ video generator                                   ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³ In this engine we use VGA mode 13h but tweaked    ³
;³ so that it's 256x256x256.  This is known as       ³
;³ Chained Mode Q.  Chained here means the VGA       ³
;³ acts as though it's a linear address space.       ³
;³                                                   ³
;³ The downside to chained modes is we can only      ³
;³ "see" 65536 bytes of the VGA memory space, even   ³
;³ it has more to offer.  For this game, that's OK.  ³
;³                                                   ³
;³ We allocate a "back buffer" in conventional RAM   ³
;³ and all of the video generation functions operate ³
;³ on this buffer.  The flip function does the       ³
;³ copy from this buffer to the actual VRAM.         ³
;³                                                   ³
;³ The video generator is simple:                    ³
;³                                                   ³
;³ - (16) 16-color palettes.  The first 8 are for    ³
;³   backgrounds and the second 8 are for            ³
;³   sprites.  Palettes can be redefined during      ³
;³   VBLANK using the VGA hardware.                  ³
;³                                                   ³
;³ - One (or more) 64Kb banks of 8x8 background      ³
;³   tiles.  Each tile can have one of 8 palettes    ³
;³   and the palette can be changed at any time.     ³
;³                                                   ³
;³ - Two backgrounds, 32x32 8x8 tiles in size.       ³
;³   BG2 is drawn with a higher priority. Tiles      ³
;³   in the map that are 0 are transparent.          ³
;³                                                   ³
;³ - Up to 256 16x16 sprites on-screen.  Each sprite ³
;³   can be assigned one of 8 16-color palettes.     ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

vga_reg_cfg struc [bp]
    vga_reg     dw ?
    vga_func    db ?
    vga_value   db ?
    vga_flags   db ?
    vga_pad     db ?
ends

even
modeq_params:
    ; misc output
    dw  032ch
    db  00h,  0e3h,  0, 0

    ; horizonal total
    dw  03d4h
    db  00h,  05fh,  0, 0

    ; horizontal display enable end
    dw  03d4h
    db  01h,  03fh,  0, 0

    ; horizontal blank start
    dw  03d4h
    db  02h,  040h,  0, 0

    ; horizontal blank end
    dw  03d4h
    db  03h,  082h,  0, 0

    ; horizontal retrace start
    dw  03d4h
    db  04h,  04ah,  0, 0

    ; horizontal retrace end
    dw  03d4h
    db  05h,  09ah,  0, 0

    ; vertical total
    dw  03d4h
    db  06h,  023h,  0, 0

    ; overflow register
    dw  03d4h
    db  07h,  0b2h,  0, 0

    ; preset row scan
    dw  03d4h
    db  08h,     0,  0, 0

    ; max scan line/char horizontal time
    dw  03d4h
    db  09h,  061h,  0, 0

    ; vertical retrace start
    dw  03d4h
    db  010h,  0ah,  0, 0

    ; vertical retrace end
    dw  03d4h
    db  011h, 0ach,  0, 0

    ; vertical display enable end
    dw  03d4h
    db  012h, 0ffh,  0, 0

    ; offset/logical width
    dw  03d4h
    db  013h, 020h,  0, 0

    ; underline location
    dw  03d4h
    db  014h, 040h,  0, 0

    ; vertical blank start
    dw  03d4h
    db  015h,  07h,  0, 0

    ; vertical blank end
    dw  03d4h
    db  016h, 01ah,  0, 0

    ; mode control
    dw  03d4h
    db  017h, 0a3h,  0, 0

    ; clock mode register
    dw  03c4h
    db  01h,     1,  0, 0

    ; memory mode register
    dw  03c4h
    db  04h,   0eh,  0, 0

    ; mode register
    dw  03ceh
    db  05h,  040h,  0, 0

    ; misc register
    dw  03ceh
    db  06h,   05h,  0, 0

    ; mode control
    dw  03c0h
    db  010h, 041h, 32, 0

    ; horizontal panning
    dw  03c0h
    db  013h,    0, 32, 0

    ; end marker
    dw  0
    db  0,       0,  0, 0

include font.8

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ font_init                                         ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³ this function uses the BIOS to grab the seg:off   ³
;³ for the 8x8 and 8x14 fonts for use in put_char.   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
font_init:
    mov     ax, 01130h
    mov     bx, 0300h
    int     10h

    mov     ax, bp
    mov     bp, offset small_font
    mov     f_segment, es
    mov     f_offset, ax
    mov     f_width, 8
    mov     f_height, 8
    mov     f_mask, 1000_0000xb

    mov     ax, 01130h
    mov     bx, 0200h
    int     10h

    mov     ax, bp
    mov     bp, offset large_font
    mov     f_segment, es
    mov     f_offset, ax
    mov     f_width, 8
    mov     f_height, 14
    mov     f_mask, 1000_0000xb

    mov     bp, offset micro_font
    mov     f_segment, cs
    mov     f_offset, offset micro_font_bits
    mov     f_width, 5
    mov     f_height, 5
    mov     f_mask, 0001_0000xb

    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ string generators                                 ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
_string:
    struc [bp]
                dw ?
        str_fnt dw ?
        str_ptr dw ?
        str_y   db ?
        str_x   db ?
        str_pal db ?
        str_clr db ?
        str_pad db ?
        str_sbc db ?
    ends

    mov     bp, sp
    mov     si, str_ptr
    xor     cx, cx
    cs mov  cl, b[si]
    inc     si
    mov     bh, str_y
    mov     bl, str_x
    mov     dl, str_pal
    shl     dl, 4
    add     dl, str_clr
    mov     dh, str_sbc
    mov     bp, str_fnt
    mov     ds, f_segment
    cs mov  es, back_buffer_ptr
s0: push    bx, cx, dx
    cs mov  al, [si]
    mul     f_height
    mov     di, f_offset
    add     di, ax
    mov     dh, f_width
    mov     ch, f_height
c0: mov     ah, f_mask
    ds mov  al, [di]
c1: mov     cl, al
    and     cl, ah
    jz      >c2
    es mov  [bx], dl
c2: inc     bl
    shr     ah, 1
    jne     c1
    inc     di
    inc     bh
    sub     bl, dh
    dec     ch
    jne     c0
    pop     dx, cx, bx
    inc     si
    cs add  bl, f_width
    add     bl, dh
    loop    s0
    ret

string macro
    push    bp, si, di, ax, bx, cx, dx
    push    #5, #4, #3, #2, #1
    call    _string
    add     sp, 10
    pop     dx, cx, bx, ax, di, si, bp
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ vram and back buffer                              ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
clear_page:
    cs mov  es, back_buffer_ptr
    mov     di, 0
    mov     cx, (VRAM_SIZE / 2) + 2
    mov     ax, 07f7fh
    cld
    es rep  stosw
    ret

clear macro
    push    es, di, cx, ax
    call    clear_page
    pop     ax, cx, di, es
#em

copy_page:
    cs mov  ds, back_buffer_ptr
    mov     es, VRAM
    mov     si, 0
    mov     di, 0
    mov     cx, (VRAM_SIZE / 2) + 2
    cld
l0: ds lodsw
    es stosw
    loop    l0
l1: ret

flip macro
    push    es, ds, si, di, cx, ax
    call    copy_page
    pop     ax, cx, di, si, ds, es
#em

scron macro
    push    ax, dx
    inp     IS1_RC
    outp    ATT_IW, 020h
    pop     dx, ax
#em

scroff macro
    push    ax, dx
    inp     IS1_RC
    outp    ATT_IW, 0
    pop     dx, ax
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ palettes                                          ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
store_palette:
    struc [bp]
                dw ?
                db ?
        pal_n   db ?
                db ?
        pal_r   db ?
                db ?
        pal_g   db ?
                db ?
        pal_b   db ?
    ends

    mov     bp, sp
    mov     dx, PEL_IW
    mov     al, pal_n
    out     dx, al
    mov     dx, PEL_D
    mov     al, pal_r
    out     dx, al
    mov     al, pal_g
    out     dx, al
    mov     al, pal_b
    out     dx, al
    ret

stpal macro
    push    bp, ax, bx, cx, dx
    push    #4, #3, #2, #1
    call    set_palette
    add     sp, 8
    pop     dx, cx, bx, ax, bp
#em

load_palettes:
    ret

ldpals macro
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ background generators                             ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ldbg1 macro
    push    ax, bx
    cs mov  es, ctrl_ram_ptr
    mov     bp, 0
    es mov  ds, c_bg_tiles
    es mov  bp, offset c_bg1
    mov     ax, #1
    shl     ax, (type tile) / 2
    add     bp, ax
    es mov  ax, t_tile
    mov     bx, TILE_WIDTH * TILE_LINES
    mul     bx
    mov     si, ax
    pop     bx, ax
#em

_video_bg1:
    xor     di, di
    xor     bx, bx
    mov     ch, 32
    mov     cl, 32
l0: ldbg1   di

    push    bx, cx
    es mov  dl, t_pal
    shl     dl, 4
    cs mov  es, back_buffer_ptr
    mov     ch, TILE_LINES
    mov     cl, TILE_WIDTH
l1: ds mov  al, [si]
    aam     16
    add     ah, dl
    es mov  [bx], ah
    inc     bl
    add     al, dl
    es mov  [bx], al
    inc     bl
    inc     si
    dec     cl
    jnz     l1
    mov     cl, TILE_WIDTH
    inc     bh
    sub     bl, TILE_WIDTH * 2
    dec     ch
    jnz     l1
    pop     cx, bx

    inc     di
    add     bl, TILE_WIDTH * 2
    dec     cl
    jne     l0
    mov     bl, 0
    add     bh, TILE_LINES
    mov     cl, 32
    dec     ch
    jne     l0
    ret

video_bg1 macro
    push    es, ds, bp, ax, bx, cx, dx, si, di
    call    _video_bg1
    pop     di, si, dx, cx, bx, ax, bp, ds, es
#em

ldbg2 macro
    push    bx, dx
    cs mov  es, ctrl_ram_ptr
    mov     bp, 0
    es mov  ds, c_bg_tiles
    es mov  bp, offset c_bg2
    mov     ax, #1
    shl     ax, (type tile) / 2
    add     bp, ax
    es mov  ax, t_tile
    mov     bx, TILE_WIDTH * TILE_LINES
    mul     bx
    mov     si, ax
    pop     dx, bx
#em

_video_bg2:
    xor     di, di
    xor     bx, bx
    mov     ch, 32
    mov     cl, 32
l0: ldbg2   di
    es mov  ax, t_tile
    cmp     ax, 0
    jz      >l4
    push    bx, cx
    es mov  dl, t_pal
    shl     dl, 4
    cs mov  es, back_buffer_ptr
    mov     ch, TILE_LINES
    mov     cl, TILE_WIDTH
l1: ds mov  al, [si]
    aam     16
    cmp     ah, 0
    jz      >l2
    add     ah, dl
    es mov  [bx], ah
l2: inc     bl
    cmp     al, 0
    jz      >l3
    add     al, dl
    es mov  [bx], al
l3: inc     bl
    inc     si
    dec     cl
    jnz     l1
    mov     cl, TILE_WIDTH
    inc     bh
    sub     bl, TILE_WIDTH * 2
    dec     ch
    jnz     l1
    pop     cx, bx
l4: inc     di
    add     bl, TILE_WIDTH * 2
    dec     cl
    jz      >l5
    jmp     l0
l5: mov     bl, 0
    add     bh, TILE_LINES
    mov     cl, 32
    dec     ch
    jz      >l6
    jmp     l0
l6: ret

video_bg2 macro
    push    es, ds, bp, ax, bx, cx, dx, si, di
    call    _video_bg2
    pop     di, si, dx, cx, bx, ax, bp, ds, es
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ sprite generators                                 ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

loadspr macro
    push    cx, dx
    cs mov  es, ctrl_ram_ptr
    mov     bp, 0
    es mov  ds, c_spr_tiles
    es mov  bp, offset c_sprs
    mov     ax, #1
    shl     ax, (type sprite) / 2
    add     bp, ax
    es mov  ax, s_tile
    mov     bx, SPR_WIDTH * SPR_LINES
    mul     bx
    mov     si, ax
    pop     dx, cx
#em

setspr macro
    es mov  s_tile, #1
    es mov  s_pal, #2
    es mov  s_y, #3
    es mov  s_x, #4
    es mov  s_flags, #5
    es mov  s_user, #6
#em

_video_fg:
    mov     cx, 0ffh
l0: loadspr cx
    es mov  al, s_flags
    test    al, F_SPR_ENABLED
    jz      >l4
    es mov  dl, s_pal
    shl     dl, 4
    add     dl, 128
    es mov  bh, s_y
    es mov  bl, s_x
    push    cx
    cs mov  es, back_buffer_ptr
    mov     ch, SPR_LINES
    mov     cl, SPR_WIDTH
l1: ds mov  al, [si]
    aam     16
    cmp     ah, 0
    jz      >l2
    add     ah, dl
    es mov  [bx], ah
l2: inc     bl
    cmp     al, 0
    jz      >l3
    add     al, dl
    es mov  [bx], al
l3: inc     bl
    inc     si
    dec     cl
    jnz     l1
    mov     cl, SPR_WIDTH
    inc     bh
    sub     bl, SPR_WIDTH * 2
    dec     ch
    jnz     l1
    pop     cx
l4: cmp     cx, 0
    jz      >l5
    dec     cx
    jmp     l0
l5: ret

video_fg macro
    push    es, ds, bp, ax, bx, cx, dx, si, di
    call    _video_fg
    pop     di, si, dx, cx, bx, ax, bp, ds, es
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ put_pixel                                         ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
put_pixel:
    struc [bp]
                dw ?
        pix_y   db ?
        pix_x   db ?
        pix_pal db ?
        pix_clr db ?
    ends

    mov     ah, pix_y
    mov     al, pix_x
    mov     di, ax
    cs mov  es, back_buffer_ptr
    es mov  [di], cl
    ret

pixel macro
    push    bp, ax, cx, di, es
    push    #2, #1
    call    put_pixel
    add     sp, 4
    pop     es, di, cx, ax, bp
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ hline & vline                                     ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
_hline:
    struc [bp]
                dw ?
        hl_y    db ?
        hl_x    db ?
        hl_w    dw ?
        hl_pal  db ?
        hl_clr  db ?
    ends
    mov     bp, sp
    mov     bl, hl_pal
    shl     bl, 4
    add     bl, hl_clr
    mov     ah, hl_y
    mov     al, hl_x
    mov     cx, hl_w
    cs mov  es, back_buffer_ptr
l0: mov     di, ax
    es mov  [di], bl
    inc     al
    loop    l0
    ret

hline macro
    push    es, bp, ax, bx, cx, di
    push    #3, #2, #1
    call    _hline
    add     sp, 6
    pop     di, cx, bx, ax, bp, es
#em

_vline:
    struc [bp]
                dw ?
        vl_y    db ?
        vl_x    db ?
        vl_h    dw ?
        vl_pal  db ?
        vl_clr  db ?
    ends
    mov     bp, sp
    mov     bl, vl_pal
    shl     bl, 4
    add     bl, vl_clr
    mov     ah, vl_y
    mov     al, vl_x
    mov     cx, vl_h
    cs mov  es, back_buffer_ptr
l0: mov     di, ax
    es mov  [di], bl
    inc     ah
    loop    l0
    ret

vline macro
    push    es, bp, ax, bx, cx, di
    push    #3, #2, #1
    call    _vline
    add     sp, 6
    pop     di, cx, bx, ax, bp, es
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ rect & frect                                      ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
_rect:
    struc [bp]
                dw ?
        r_y     db ?
        r_x     db ?
        r_h     db ?
        r_w     db ?
        r_pal   db ?
        r_clr   db ?
    ends

    mov     bp, sp
    xor     dx, dx
    mov     dl, r_pal
    shl     dl, 4
    add     dl, r_clr
    mov     bh, r_y
    mov     bl, r_x
    xor     cx, cx
    mov     cl, r_w
    inc     cl
    cs mov  es, back_buffer_ptr
l0: es mov  [bx], dl
    add     bh, r_h
    es mov  [bx], dl
    sub     bh, r_h
    inc     bl
    loop    l0

    mov     cl, r_h
    mov     bh, r_y
    mov     bl, r_x
l1: es mov  [bx], dl
    add     bl, r_w
    es mov  [bx], dl
    sub     bl, r_w
    inc     bh
    loop    l1

    ret

rect macro
    push    es, bp, ax, bx, cx, dx
    push    #3, #2, #1
    call    _rect
    add     sp, 6
    pop     dx, cx, bx, ax, bp, es
#em

_frect:
    struc [bp]
                dw ?
        fr_y    db ?
        fr_x    db ?
        fr_h    db ?
        fr_w    db ?
        fr_pal  db ?
        fr_clr  db ?
    ends

    mov     bp, sp
    mov     al, fr_pal
    shl     al, 4
    add     al, hl_clr
    mov     bh, fr_y
    mov     bl, fr_x
    mov     ch, fr_h
    mov     cl, fr_w
    cs mov  es, back_buffer_ptr
l0: es mov  [bx], al
    inc     bl
    dec     cl
    cmp     cl, 0
    jnz     l0
    mov     cl, fr_w
    sub     bl, cl
    inc     bh
    dec     ch
    cmp     ch, 0
    jnz     l0
    ret

frect macro
    push    bp, ax, bx, cx, dx
    push    #3, #2, #1
    call    _frect
    add     sp, 6
    pop     dx, cx, bx, ax, bp
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ _is_vblank                                        ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
_is_vblank:
    mov     dx, IS1_RC
    in      al, dx
    and     al, 00001000xb
    ret

is_vblank macro
    push    dx
    call    _is_vblank
    pop     dx
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ wait_vblank                                       ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
_wait_vblank:
l0: mov     dx, IS1_RC
    in      al, dx
    and     al, 00001000xb
    jz      l0
    ret

wait_vblank macro
    push    dx, ax
    call    _wait_vblank
    pop     ax, dx
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ wait_novblank                                     ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
_wait_novblank:
l0: mov     dx, IS1_RC
    in      al, dx
    and     al, 00001000xb
    jnz     l0
    ret

wait_novblank macro
    push    dx, ax
    call    _wait_novblank
    pop     ax, dx
#em

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³ graphics mode functions & macros                  ³
;ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³                                                   ³
;³                                                   ³
;³                                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
mode_13 macro
    mov     ah, 0
    mov     al, 13h
    int     10h
    call    font_init
#em

mode_03 macro
    mov     ah, 0
    mov     al, 3
    int     10h
#em

_mode_q:
    mov     dx, CRT_IC
    mov     al, 011h
    out     dx, al
    inc     dx
    in      al, dx
    and     al, 07fh
    mov     ah, al
    mov     al, 011h
    dec     dx
    out     dx, ax
    mov     bp, modeq_params
l2: mov     dx, vga_reg
    cmp     dx, 0
    je      >l0
    mov     al, vga_func
    mov     bl, vga_flags
    cmp     bl, 0
    jz      >l1
    add     al, bl
l1: out     dx, al
    inc     dx
    mov     al, vga_value
    out     dx, al
    add     bp, type vga_reg_cfg
    jmp     l2
l0: mov     dx, CRT_IC
    mov     al, 011h
    out     dx, al
    inc     dx
    in      al, dx
    or      al, 080h
    mov     ah, al
    mov     al, 011h
    dec     dx
    out     dx, ax
    ret

mode_q macro
    push    bp, ax, bx, dx
    call    _mode_q
    pop     dx, bx, ax, bp
#em

;
;
;

